" First and Foremost {{{ ============================================
set nocompatible " Forget compatibility with vi (This must be first)

set encoding=utf-8
set fenc=utf-8
set termencoding=utf-8

" set a map leader for more key combos
let mapleader = ' '
let g:mapleader = ' '
" save a lot of unneeded shifting
noremap ; :
noremap : ;
" bad habit become useful to quit insert mode
inoremap jk <Esc>
" }}}
" Autoinstall vim-plug {{{ ==========================================
if empty(glob('~/.config/nvim/autoload/plug.vim'))
  silent !curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall
endif
" }}}
" Plugins with their settings "{{{ ==================================
call plug#begin('~/.config/nvim/plugged')
" colorscheme & appearance ----------------------
"Plug 'chriskempson/base16-vim'          " preview : http://chriskempson.github.io/base16/
"Plug 'sjl/badwolf'
Plug 'itchyny/lightline.vim'            " a lightweight customizable statusline
    " settings for lightline {{{
    let g:lightline = {
        \ 'colorscheme' : 'Tomorrow_Night_Eighties',
        \ 'active': {
        \   'left': [ [ 'mode', 'paste' ],
        \             [ 'fugitive', 'filename' ] ]
        \ },
        \ 'component': {
        \   'fugitive': '%{exists("*fugitive#head") ? " ".fugitive#head() : ""}'
        \ },
        \ 'component_function': {
        \   'readonly': 'LightLineReadonly',
        \   'modified': 'LightLineModified',
        \   'filename': 'LightLineFilename'
        \ },
        \ 'separator': { 'left': '', 'right': '' },
        \ 'subseparator': { 'left': '', 'right': '' }
        \ }

    function! LightLineModified()
    if &filetype == "help"
        return ""
    elseif &modified
        return "+"
    elseif &modifiable
        return ""
    else
        return ""
    endif
    endfunction

    function! LightLineReadonly()
    if &filetype == "help"
        return ""
    elseif &readonly
        return ""
    else
        return ""
    endif
    endfunction

    function! LightLineFilename()
    return ('' != LightLineReadonly() ? LightLineReadonly() . ' ' : '') .
        \ ('' != expand('%:t') ? expand('%:t') : '[No Name]') .
        \ ('' != LightLineModified() ? ' ' . LightLineModified() : '')
    endfunction
    "}}}
Plug 'jszakmeister/vim-togglecursor'
Plug 'junegunn/rainbow_parentheses.vim' " visualize nested parentheses
    " settings for rainbow_parentheses {{{
    let g:rainbow#max_level = 8
    let g:rainbow#pairs = [['(', ')'], ['[', ']']]
    " Activate rainbow_parentheses
    if has('autocmd') && !exists('autocommands_loaded') " Make sure Vim has autocmd support
        autocmd VimEnter * RainbowParentheses
    endif
    "}}}
Plug 'itchyny/landscape.vim'

" utilities ------------------------------------
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
    " settings for fzf {{{
    let $FZF_DEFAULT_COMMAND = 'ag --hidden --ignore .git -g ""'
    let g:fzf_height='35%'
    let g:fzf_action = {
        \ 'ctrl-t': 'tab split',
        \ 'ctrl-s': 'split',
        \ 'ctrl-v': 'vsplit'
        \ }

    if executable('fzf')
        " <C-p> or <C-t> to search files (-m means multi-select with (shift)tab)
        noremap <silent> <C-p> :FZF -m --no-hscroll<cr>
        
        " Open files in vertical horizontal split
        nnoremap <silent> <Leader>v :call fzf#run({
        \   'right': winwidth('.') / 2,
        \   'sink':  'vertical botright split' })<CR>

        " <M-p> for open buffers
        nnoremap <silent> <M-p> :Buffers<cr>

        " <M-S-p> for MRU
        nnoremap <silent> <M-S-p> :History<cr>

    else
    " CtrlP fallback
    end
    " }}}
" use ack and ag as a replacement for vim's built in grep and vimgrep
Plug 'mileszs/ack.vim'              " search inside files (:Ack <keywords>) --> ? --> o/v ...
    " settings for Ack/Ag {{{
    nnoremap <silent> <leader>/ :execute 'Ack ' . input('Ack/')<CR>
    if executable('ag')
        let g:ackprg = 'ag --nogroup --nocolor --column'
    endif

    nnoremap <silent> S :call SearchWordWithAg()<CR>
    vnoremap <silent> <C-F> :call SearchVisualSelectionWithAg()<CR>

    function! SearchWordWithAg()
        execute 'Ack' expand('<cword>')
    endfunction

    function! SearchVisualSelectionWithAg() range
        let old_reg = getreg('"')
        let old_regtype = getregtype('"')
        let old_clipboard = &clipboard
        set clipboard&
        normal! ""gvy
        let selection = getreg('"')
        call setreg('"', old_reg, old_regtype)
        let &clipboard = old_clipboard
        execute 'Ack' selection
    endfunction
    " }}}
Plug 'tpope/vim-fugitive'
Plug 'airblade/vim-gitgutter'
Plug 'benmills/vimux'               " interact with tmux to run commands (project-specific settings at <project>.vimrc)
Plug 'sjl/gundo.vim'                " require to install python2-neovim (remap to <leader>-u)
    " settings for toggle gundo {{{
    nnoremap <leader>u :GundoToggle<CR>
    " }}}
Plug 'majutsushi/tagbar'            " require to install ctags
Plug 'scrooloose/nerdtree'         " file browser (remap to <leader>-k)
    " settings for NERDTree {{{
    let g:NERDTreeQuitOnOpen=1          " close NERDTree after a file is opened
    let NERDTreeShowHidden=1            " show hidden files in NERDTree
    let NERDTreeIgnore = ['\.js.map$']  " remove some files by extension
    noremap <silent> <leader>k :NERDTreeToggle<cr> 
    " expand to the path of the file in the current buffer
    noremap <silent> <leader><S-k> :NERDTreeFind<cr>
    " }}}

"Plug 'easymotion/vim-easymotion'

"Plug 'ctrlpvim/ctrlp.vim'          " fuzzy search (of course, C-p)
    " settings for CtrlP {{{
    let g:ctrlp_dotfiles = 1                " enable search for dotfiles
    let g:ctrlp_match_window = 'bottom,order:ttb'
    let g:ctrlp_switch_buffer = 0           " always open files in new buffers
    let g:ctrlp_working_path_mode = 0
    " use ag (an external command) to improve finding maching files
    let g:ctrlp_user_command = 'ag %s -l --nocolor --hidden -g ""'
    " }}}

" language-specific plugins --------------------

call plug#end()
" }}}
" Source my own custom functions and settings "{{{ ==================
function! Source(vimfile)
	let src=a:vimfile
	if strlen(src) && filereadable(src)
		exec ':source' . src
	endif
endfunction

"automatically sources all file in autosource
for fpath in split(globpath('~/.config/nvim/autosource/', '*.vim'), '\n')
	:call Source(fpath)
endfor
"}}}
" Code folding settings {{{ =========================================
set foldmethod=syntax   "fold based on indentation, rather than markers
set foldlevel=0         "fold level-0 when openning a file
set modelines=1         "check just the final line of the file for a modeline
set foldopen=block,hor,insert,jump,mark,percent,quickfix,search,tag,undo
                        " which commands trigger auto-unfold
" }}}
" Indentation  {{{ ==================================================
" Lines too long to fit on one screen will be truncated.
set nowrap
let &showbreak='↪ '
" Force a 79 column policy with an auto-break on words in comments to assure 
" maximum readability. Visually add a column to see where the cut will be.
set linebreak
set colorcolumn=81
set textwidth=80
" Create two format modes, for code and for text
" c : Comments are wrapped based on textwidth
" r : New line in comment is a comment when pressing <Enter>
" o : New line in comment is a comment when pressing o or O
" n : Handles list while formatting
" q : Comments can be re-wrapped using gq
" 1 : Do not end lines with one-char words
set formatoptions=cronq1
" }}}
" Spaces & Tabs {{{ =================================================
set tabstop=4       " number of visual spaces per TAB
set softtabstop=4   " when hitting <BS>, pretend like a tab is removed, even if spaces
set expandtab       " insert tabs rather than spaces for <Tab>

set shiftwidth=4    " number of spaces to use for autoindenting
set shiftround      " use multiple of shiftwidth when indenting with '<' and '>'

" invisible characters
set invlist
set listchars=tab:▸\ ,eol:¬,trail:⋅,extends:❯,precedes:❮
"set listchars=precedes:←,extends:→,nbsp:◊,trail:⠿,eol:\ ,tab:●·
highlight SpecialKey ctermbg=none " make the highlighting of tabs less annoying
set showbreak=↪
noremap <leader>l :set list!<cr>
" }}}
" Aesthetics & User Inferace Config {{{ =============================
set t_Co=256
let base16colorspace=256  " Access colors present in 256 colorspace"

execute "set background=".$BACKGROUND
"execute "colorscheme ".$THEME
colorscheme badwolf     " config badwolf (https://github.com/sjl/badwolf)
set number
set relativenumber      "take a look at AUTOCMD section
"set numberwidth=3

" switch syntax highlighting on, when the terminal has colors
if &t_Co > 2 || has("gui_running") | syntax enable | endif

set noshowmode          "hide INSERT-VISUAL...text, we already have statusbar 
"set showcmd             "Show more info about current command
" }}}
" Search & Replace {{{ ==============================================
"automatically inserting a \v for searching using regex
nnoremap / /\v

set gdefault    " applies substitutions globally on lines instead of the first occurrance
set hlsearch    " highlight the search result
set incsearch   " set incremental search, like modern browsers
set showmatch   " show matching braces
set ignorecase  " case insensitive searching
set smartcase   " case-sensitive if expresson contains a capital letter
" }}}
" Backups and Undo {{{ ==============================================
" Keep undo history across sessions, by storing in file.
if has('persistent_undo') && !isdirectory(expand('~').'/.vim/undo')
    silent !mkdir ~/.vim/undo > /dev/null 2>&1
endif

set undofile
set undodir=~/.vim/undo

set nobackup                " do not keep backup files, it's 70's style cluttering
set noswapfile              " do not write annoying intermediate swap files,
                            "    who did ever restore from swap files anyway?

" store swap files in one of these directories (in case swapfile is ever turned on)
set directory=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
" }}}
" General shortcuts for functionality {{{ ===========================
" shortcut to save
noremap <leader><leader> :w<cr>
noremap <C-s> :w<cr>
noremap! <C-s> <esc>:w<cr>

" SPLIT ---------------------------------------> splitview.vim
set splitright
noremap <silent> <C-h> :call WinMove('h')<cr>
noremap <silent> <C-j> :call WinMove('j')<cr>
noremap <silent> <C-k> :call WinMove('k')<cr>
noremap <silent> <C-l> :call WinMove('l')<cr>

" Column scroll-binding on <leader>sb
noremap <silent> <leader>sb :<C-u>let @z=&so<CR>:set so=0 noscb<CR>:bo vs<CR>Ljzt:setl scb<CR><C-w>p:setl scb<CR>:let &so=@z<CR>
" remove extra whitespace at the end of each line
noremap r<space> :%s/\s\+$<cr>

" Open current fold, closing every other fold to get more focus
nnoremap zz zozMzvzz

" move vertically by each visual line for wrapped long lines
nnoremap j gj
nnoremap k gk
nnoremap <silent> ^ g^
nnoremap <silent> $ g$
nnoremap V :vnoremap j j<cr>V
nnoremap v :vnoremap j gj<cr>v
" OR : xnoremap <expr> j mode() ==# 'V' ? 'j' : 'gj'

" set paste toggle
set pastetoggle=<F6>
" toggle paste mode
map <leader>v :set paste!<cr>

" insert a new line after/before the current line
noremap <CR> o<Esc>

" clear highlighted searches
noremap <silent> ,/ :nohlsearch<CR>
" search for word under the cursor
"nnoremap <leader>/ "fyiw :/<c-r>f<cr>

" for when you forgot to sudo before editing a file that requires root privileges
cmap w!! w !sudo tee % >/dev/null

"visually select recently entered text
nnoremap gV `[v`]

"toggle between bracket pairs
nnoremap <tab> %

" enable . command in visual mode
vnoremap . :normal .<cr>
" switch between current and last buffer
nmap <leader>. <c-^>
" wipout buffer
nmap <silent> <leader>b :bw<cr>

" }}}
" AUTOCOMD : cursor highlight, file type-specific settings, etc. ====
    if has('autocmd') && !exists('autocommands_loaded') " Make sure Vim has autocmd support
	" Filetype-specific autocommands --------------------------------"{{{
    augroup filespecific
        "directive clears all the autocmd's for the current group.
        autocmd! 
        au BufRead,BufNewFile *.json set ft=javascript
        autocmd FileType html setlocal ts=4 sts=4 sw=4 noexpandtab indentkeys-=*<return>
        autocmd FileType help nested call ILikeHelpToTheRight()
	augroup END
    " }}}
    " Open help files vertically ------------------------------------"{{{
    function! ILikeHelpToTheRight()
    if !exists('w:help_is_moved') || w:help_is_moved != "right"
        wincmd L
        let w:help_is_moved = "right"
    endif
    endfunction
    " }}}
	" When editing a file, always jump to the last known cursor position.{{{
	" Don't do it when the position is invalid or when inside an event handler
	" (happens when dropping a file on gvim).
	autocmd BufReadPost *
		\ if line("'\"") > 0 && line("'\"") <= line("$") |
		\   exe "normal g`\"" |
		\ endif
	" }}}
	" Reload .vimrc and .gvimrc files as soon as they have a change -"{{{
	augroup VimReload
		autocmd!
		autocmd BufWritePost $MYVIMRC source $MYVIMRC
		autocmd BufWritePost $MYGVIMRC source $MYGVIMRC
	augroup END
	" }}}
	" Mode-aware settings (colorize line number/line/column ...) ----"{{{
	" forks of http://stackoverflow.com/questions/15561132/run-command-when-vim-enters-visual-mode
	augroup HiLightCursor
		autocmd!
		autocmd InsertEnter * call SetCursorColorInsert(v:insertmode)
		autocmd InsertLeave * call ResetCursorColor()
		autocmd CursorHold,CursorHoldI * call WaitingCursorColor()
		autocmd CursorMoved * call ResetCursorColor()
	augroup END

	vnoremap <silent> <expr> <SID>SetCursorColorVisual SetCursorColorVisual()
	nnoremap <silent> <script> v v<SID>SetCursorColorVisual
	nnoremap <silent> <script> V V<SID>SetCursorColorVisual
	nnoremap <silent> <script> <C-v> <C-v><SID>SetCursorColorVisual

	function! SetCursorColorInsert(mode)
	" INSERT MODE
		if a:mode == "i"
			echo "Enter Insert Mode"
			setlocal norelativenumber cursorline cursorcolumn
			highlight CursorLineNr ctermfg=3 guifg=#268bd2
			hi CursorLine ctermfg=NONE ctermbg=234 cterm=bold guifg=Cyan guibg=#3E3D32 gui=bold
			hi CursorColumn ctermfg=NONE ctermbg=234 cterm=NONE guifg=white guibg=#323D3E gui=bold
			hi Cursor ctermfg=red ctermbg=blue cterm=bold guifg=white guibg=#00AAFF gui=bold
	" REPLACE MODE
		elseif a:mode == "r"
			echo "Enter Replace Mode"
			highlight CursorLineNr ctermfg=12 guifg=#dc322f
		endif
	endfunction

	function! SetCursorColorVisual()
	" VISUAL MODE
		echo "Enter Visual Mode"
		highlight CursorLineNr cterm=none ctermfg=cyan guifg=#cb4b16
		return '' " keep the cursor from jumping the beginning of the current line when entering visual mode.
	endfunction

	function! WaitingCursorColor()
	" automatically leave insert mode after 'updatetime' milliseconds of inaction
		stopinsert " --> leaving InsertMode --> ResetCursorColor --> updatetime = 8000 --> wait for another 8s
	" Idle mode
		echo "Waiting for User..."
		setlocal relativenumber cursorline cursorcolumn
		highlight CursorLineNr cterm=none ctermfg=17 guifg=#073642
		hi Cursor cterm=inverse ctermfg=red ctermbg=red guifg=white guibg=#A6E22E gui=bold
		hi CursorLine cterm=underline ctermfg=NONE ctermbg=019 guifg=Cyan guibg=#3E3D32 gui=bold
		hi CursorColumn ctermfg=NONE ctermbg=019 cterm=bold guifg=white guibg=yellow gui=bold
	endfunction

	function! ResetCursorColor()
		set updatetime=15000 " milliseconds
	" NORMAL MODE
		echo "Back to Normal Mode"
		setlocal relativenumber cursorline cursorcolumn
		highlight CursorLineNr cterm=none ctermfg=red guifg=#073642
		hi CursorLine cterm=bold ctermbg=23
		hi CursorColumn ctermfg=NONE ctermbg=235 cterm=NONE guifg=white guibg=#323D3E gui=bold
	endfunction
	" }}}
    " Save all files on focus lost, ignoring warnings about untitled buffers {{{
    autocmd FocusLost * silent! wa
    " }}}
    endif
" OS-SPECIFIC SETTINGS & CROSS-PLATFORM SETTINGS ====================
    " System clipboard {{{ ------------------------------------------
    if has('win32') || has('win64')
        set gfn=Consolas:h10
        set clipboard=unnamed
    else
        let s:kernel = system('echo -n "$(uname -s)"')
        if s:kernel == 'Darwin'
            set guifont=Menlo:h12
            " this doesn't work in mountain lion's default vim (does on macvim)
            set clipboard=unnamed    " brew install reattach-to-user-namespace
        elseif s:kernel == 'Linux'
            set clipboard=unnamed,unnamedplus " copy/paste between gui/cli --> require xclip/xsel
        endif
    endif
    " }}}
    " Tab keybindings {{{ -------------------------------------------
	if has("gui_macvim") " OS X
		"set guifont=Monaco:h14
		set guifont=Monaco:h12
		"set noantialias
		"set transparency=15

		" Swipe to move between bufers :D
		map <silent> <SwipeLeft> :bprev<CR>
		map <silent> <SwipeRight> :bnext<CR>

		" Cmd+Shift+N = new buffer
		map <silent> <D-N> :enew<CR>

		" Cmd+t = new tab
		nnoremap <silent> <D-t> :tabnew<CR>

		" Cmd+w = close tab (this should happen by default)
		nnoremap <silent> <D-w> :tabclose<CR>

		" Cmd+1...9 = go to that tab
		map <silent> <D-1> 1gt
		map <silent> <D-2> 2gt
		map <silent> <D-3> 3gt
		map <silent> <D-4> 4gt
		map <silent> <D-5> 5gt
		map <silent> <D-6> 6gt
		map <silent> <D-7> 7gt
		map <silent> <D-8> 8gt
		map <silent> <D-9> 9gt

		" OS X probably has ctags in a weird place
		let g:tagbar_ctags_bin='/usr/local/bin/ctags'

	elseif has("gui_gtk2") " Linux
		set guifont=menlo\ 9

		" Alt+n = new buffer
		map <silent> <A-n> :enew<CR>

		" Alt+t = new tab
		nnoremap <silent> <A-t> :tabnew<CR>

		" Alt+w = close tab
		nnoremap <silent> <A-w> :tabclose<CR>

		" Alt+1...9 = go to that tab
		map <silent> <A-1> 1gt
		map <silent> <A-2> 2gt
		map <silent> <A-3> 3gt
		map <silent> <A-4> 4gt
		map <silent> <A-5> 5gt
		map <silent> <A-6> 6gt
		map <silent> <A-7> 7gt
		map <silent> <A-8> 8gt
		map <silent> <A-9> 9gt

	elseif has("gui_win32") " Windows
		" :D
	endif
" }}}
" vim:foldmethod=marker:foldlevel=0:syntax=vim
