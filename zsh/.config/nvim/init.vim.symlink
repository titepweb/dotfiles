" Vim-Plug "{{{ =====================================================
call plug#begin('~/.config/nvim/plugged')

" colorscheme & appearance ----------------------
Plug 'chriskempson/base16-vim'              " preview : http://chriskempson.github.io/base16/
Plug 'itchyny/lightline.vim'                " statusline
Plug 'jszakmeister/vim-togglecursor'
Plug 'itchyny/landscape.vim'

" utilities ------------------------------------
Plug 'tpope/vim-fugitive'
Plug 'benmills/vimux'                       " interact with tmux to run commands (project-specific settings at <project>.vimrc)

Plug 'ctrlpvim/ctrlp.vim'                   " fuzzy search (of course, C-p)
Plug 'sjl/gundo.vim'                        " require to install python2-neovim
"Plug 'easymotion/vim-easymotion'

" utilities ------------------------------------
"
call plug#end()
" }}}
" Source my own custom functions and settings "{{{ ==================
function! Source(vimfile)
	let src=a:vimfile
	if strlen(src) && filereadable(src)
		exec ':source' . src
	endif
endfunction

"automatically sources all file in autosource
for fpath in split(globpath('~/.config/nvim/autosource/', '*.vim'), '\n')
	:call Source(fpath)
endfor
"}}}
" What most important {{{ ===========================================
set nocompatible " Forget compatibility with vi (This must be first)

set encoding=utf-8
set fenc=utf-8
set termencoding=utf-8

" set a map leader for more key combos
let mapleader = ' '
let g:mapleader = ' '
" save a lot of unneeded shifting
noremap ; :
noremap : ;
" bad habit become useful to quit insert mode
inoremap jk <Esc>
" }}}
" Code folding settings {{{ =========================================
"set foldmethod=syntax  "fold based on indentation, rather than markers
set foldlevel=0         "fold level-0 when openning a file
set modelines=1         "check just the final line of the file for a modeline
" }}}
" Spaces & Tabs {{{ =================================================
set tabstop=4       " number of visual spaces per TAB
set softtabstop=4   " when hitting <BS>, pretend like a tab is removed, even if spaces
set expandtab       " insert tabs rather than spaces for <Tab>

set shiftwidth=4    " number of spaces to use for autoindenting
set shiftround      " use multiple of shiftwidth when indenting with '<' and '>'
" }}}
" User Inferace Config {{{ ==========================================
set t_Co=256
let base16colorspace=256  " Access colors present in 256 colorspace"

execute "set background=".$BACKGROUND
"execute "colorscheme ".$THEME
colorscheme badwolf

set number
set relativenumber     " take a look at AUTOCMD section
"set numberwidth=3

syntax enable           " enable syntax processing
"set showmatch           " highlight matching [{()}]

" }}}
" Searching {{{ =====================================================
set ignorecase " case insensitive searching
set smartcase " case-sensitive if expresson contains a capital letter
set hlsearch
set incsearch " set incremental search, like modern browsers
set nolazyredraw " don't redraw while executing macros

set magic " Set magic on, for regex

set showmatch " show matching braces
set mat=2 " how many tenths of a second to blink
" }}}
" Backups and Undo {{{ ==============================================
" }}}
" General shortcuts for functionality {{{ ===========================
" shortcut to save
noremap <leader><leader> :w<cr>
noremap <C-s> :w<cr>
noremap! <C-s> <esc>:w<cr>

" invisible characters
set invlist
set listchars=tab:▸\ ,eol:¬,trail:⋅,extends:❯,precedes:❮
highlight SpecialKey ctermbg=none " make the highlighting of tabs less annoying
set showbreak=↪
noremap <leader>l :set list!<cr>

" SPLIT -----------------> splitview.vim
noremap <silent> <C-h> :call WinMove('h')<cr>
noremap <silent> <C-j> :call WinMove('j')<cr>
noremap <silent> <C-k> :call WinMove('k')<cr>
noremap <silent> <C-l> :call WinMove('l')<cr>

" Column scroll-binding on <leader>sb
noremap <silent> <leader>sb :<C-u>let @z=&so<CR>:set so=0 noscb<CR>:bo vs<CR>Ljzt:setl scb<CR><C-w>p:setl scb<CR>:let &so=@z<CR>
" remove extra whitespace at the end of each line
noremap r<space> :%s/\s\+$<cr>

" Open current fold, closing every other fold to get more focus
nnoremap zz zozMzvzz

" move vertically by each visual line for wrapped long lines
nnoremap j gj
nnoremap k gk
nnoremap <silent> ^ g^
nnoremap <silent> $ g$

" set paste toggle
set pastetoggle=<F6>

" toggle paste mode
map <leader>v :set paste!<cr>

" insert a new line after/before the current line
noremap <CR> o<Esc>

" enable . command in visual mode
vnoremap . :normal .<cr>
" switch between current and last buffer
nmap <leader>. <c-^>
" wipout buffer
nmap <silent> <leader>b :bw<cr>

" clear highlighted searches
noremap <silent> ,/ :nohlsearch<CR>
" search for word under the cursor
nnoremap <leader>/ "fyiw :/<c-r>f<cr>

" for when you forgot to sudo before editing a file that requires root privileges
cmap w!! w !sudo tee % >/dev/null

" }}}
" AUTOCOMD : CURSOR HIGHLIGHT & FILE TYPE-SPECIFIC SETTINGS {{{ =====
if has('autocmd') && !exists('autocommands_loaded') " Make sure Vim has autocmd support
	" filetype-specific autocommands ---------------------------------"{{{
	augroup filespecific
      "directive clears all the autocmd's for the current group.
	  autocmd!
	  au BufRead,BufNewFile *.json set ft=javascript
	  au FileType go set noet nolist
	  au FileType python setl ts=4
	  au FileType rust setl sw=0 sts=0
	augroup END

	" When editing a file, always jump to the last known cursor position.
	" Don't do it when the position is invalid or when inside an event handler
	" (happens when dropping a file on gvim).
	autocmd BufReadPost *
		\ if line("'\"") > 0 && line("'\"") <= line("$") |
		\   exe "normal g`\"" |
		\ endif
	" }}}
	" Reload .vimrc and .gvimrc files as soon as they have a change --"{{{
	augroup VimReload
		autocmd!
		autocmd BufWritePost $MYVIMRC source $MYVIMRC
		autocmd BufWritePost $MYGVIMRC source $MYGVIMRC
	augroup END
	" }}}
	" Mode-aware settings (color (relative) line number, colorize line/column ...)"{{{
	" forks of http://stackoverflow.com/questions/15561132/run-command-when-vim-enters-visual-mode
	set noshowmode
	augroup HiLightCursor
		autocmd!
		autocmd InsertEnter * call SetCursorColorInsert(v:insertmode)
		autocmd InsertLeave * call ResetCursorColor()
		autocmd CursorHold,CursorHoldI * call WaitingCursorColor()
		autocmd CursorMoved * call ResetCursorColor()
	augroup END

	vnoremap <silent> <expr> <SID>SetCursorColorVisual SetCursorColorVisual()
	nnoremap <silent> <script> v v<SID>SetCursorColorVisual
	nnoremap <silent> <script> V V<SID>SetCursorColorVisual
	nnoremap <silent> <script> <C-v> <C-v><SID>SetCursorColorVisual

	function! SetCursorColorInsert(mode)
	" INSERT MODE
		if a:mode == "i"
			echo "Enter Insert Mode"
			setlocal norelativenumber cursorline cursorcolumn
			highlight CursorLineNr ctermfg=3 guifg=#268bd2
			hi CursorLine ctermfg=NONE ctermbg=234 cterm=bold guifg=Cyan guibg=#3E3D32 gui=bold
			hi CursorColumn ctermfg=NONE ctermbg=234 cterm=NONE guifg=white guibg=#323D3E gui=bold
			hi Cursor ctermfg=red ctermbg=blue cterm=bold guifg=white guibg=#00AAFF gui=bold
	" REPLACE MODE
		elseif a:mode == "r"
			echo "Enter Replace Mode"
			highlight CursorLineNr ctermfg=12 guifg=#dc322f
		endif
	endfunction

	function! SetCursorColorVisual()
	" VISUAL MODE
		echo "Enter Visual Mode"
		highlight CursorLineNr cterm=none ctermfg=cyan guifg=#cb4b16
		return '' " keep the cursor from jumping the beginning of the current line when entering visual mode.
	endfunction

	function! WaitingCursorColor()
	" automatically leave insert mode after 'updatetime' milliseconds of inaction
		stopinsert " --> leaving InsertMode --> ResetCursorColor --> updatetime = 8000 --> wait for another 8s
	" Idle mode
		echo "Waiting for User..."
		setlocal relativenumber cursorline cursorcolumn
		highlight CursorLineNr cterm=none ctermfg=17 guifg=#073642
		hi Cursor cterm=inverse ctermfg=red ctermbg=red guifg=white guibg=#A6E22E gui=bold
		hi CursorLine cterm=underline ctermfg=NONE ctermbg=019 guifg=Cyan guibg=#3E3D32 gui=bold
		hi CursorColumn ctermfg=NONE ctermbg=019 cterm=bold guifg=white guibg=yellow gui=bold
	endfunction

	function! ResetCursorColor()
		set updatetime=15000 " milliseconds
	" NORMAL MODE
		echo "Back to Normal Mode"
		setlocal relativenumber cursorline cursorcolumn
		highlight CursorLineNr cterm=none ctermfg=red guifg=#073642
		hi CursorLine cterm=bold ctermbg=23
		hi CursorColumn ctermfg=NONE ctermbg=235 cterm=NONE guifg=white guibg=#323D3E gui=bold
	endfunction
	" }}}
endif
" }}}
" OS-SPECIFIC SETTINGS & CROSS-PLATFORM {{{ =========================
if has('win32') || has('win64')
	set gfn=Consolas:h10
	set clipboard=unnamed
else
	let s:kernel = system('echo -n "$(uname -s)"')
	if s:kernel == 'Darwin'
		set gfn=Menlo:h12
		" this doesn't work in mountain lion's default vim (does on macvim)
		set clipboard=unnamed    " brew install reattach-to-user-namespace
	elseif s:kernel == 'Linux'
		set clipboard=unnamed,unnamedplus " copy/paste between gui/cli --> require xclip/xsel
	endif
endif
" }}}
" PLUGIN SETTINGS ===================================================
" toggle gundo {{{
nnoremap <leader>u :GundoToggle<CR>

" toggle cursor {{{

" }}}

" CtrlP {{{
let g:ctrlp_dotfiles = 1                " enable search for dotfiles
let g:ctrlp_match_window = 'bottom,order:ttb'
let g:ctrlp_switch_buffer = 0           " always open files in new buffers
let g:ctrlp_working_path_mode = 0
" use ag (an external command) to improve finding maching files
let g:ctrlp_user_command = 'ag %s -l --nocolor --hidden -g ""'
"}}} ------------------------------------------------------
" }}}
" lightline {{{
let g:lightline = {
	\ 'colorscheme' : 'Tomorrow_Night_Eighties',
	\ 'active': {
	\   'left': [ [ 'mode', 'paste' ],
	\             [ 'fugitive', 'filename' ] ]
	\ },
	\ 'component': {
	\   'fugitive': '%{exists("*fugitive#head") ? " ".fugitive#head() : ""}'
	\ },
	\ 'component_function': {
	\   'readonly': 'LightLineReadonly',
	\   'modified': 'LightLineModified',
	\   'filename': 'LightLineFilename'
	\ },
	\ 'separator': { 'left': '', 'right': '' },
	\ 'subseparator': { 'left': '', 'right': '' }
	\ }

function! LightLineModified()
  if &filetype == "help"
    return ""
  elseif &modified
    return "+"
  elseif &modifiable
    return ""
  else
    return ""
  endif
endfunction

function! LightLineReadonly()
  if &filetype == "help"
    return ""
  elseif &readonly
    return ""
  else
    return ""
  endif
endfunction

function! LightLineFilename()
  return ('' != LightLineReadonly() ? LightLineReadonly() . ' ' : '') .
       \ ('' != expand('%:t') ? expand('%:t') : '[No Name]') .
       \ ('' != LightLineModified() ? ' ' . LightLineModified() : '')
endfunction
"}}}
" vim:foldmethod=marker:foldlevel=0:syntax=vim
